"use strict";var l=Object.defineProperty;var R=Object.getOwnPropertyDescriptor;var A=Object.getOwnPropertyNames;var T=Object.prototype.hasOwnProperty;var w=(r,e)=>()=>(r&&(e=r(r=0)),e);var p=(r,e)=>{for(var t in e)l(r,t,{get:e[t],enumerable:!0})},$=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let a of A(e))!T.call(r,a)&&a!==t&&l(r,a,{get:()=>e[a],enumerable:!(n=R(e,a))||n.enumerable});return r};var E=r=>$(l({},"__esModule",{value:!0}),r);var S={};p(S,{createLogger:()=>k,default:()=>v});function k(r){let e=`[${r}]`;return{debug:(t,n)=>{process.env.LOG_LEVEL==="debug"&&console.log(`${new Date().toISOString()} DEBUG ${e} ${t}`,n||"")},info:(t,n)=>{console.log(`${new Date().toISOString()} INFO ${e} ${t}`,n||"")},warn:(t,n)=>{console.warn(`${new Date().toISOString()} WARN ${e} ${t}`,n||"")},error:(t,n)=>{console.error(`${new Date().toISOString()} ERROR ${e} ${t}`,n||"")}}}var v,I=w(()=>{"use strict";v=k});var y={};p(y,{EXCHANGES:()=>H,GEOGRAPHIC_HIERARCHY:()=>G,QUEUE_PREFIXES:()=>N,RoutingKeyBuilder:()=>d});var d,H,N,G,C=w(()=>{"use strict";d=class{static buildKey(e,t){let n=[];return e.continent&&n.push(e.continent),e.region&&n.push(e.region),e.country&&n.push(e.country),e.city&&n.push(e.city),e.workerId&&n.push(e.workerId),t&&n.length<5&&n.push("*"),n.join(".")}static parseKey(e){let t=e.split("."),n={};return t[0]&&t[0]!=="*"&&(n.continent=t[0]),t[1]&&t[1]!=="*"&&(n.region=t[1]),t[2]&&t[2]!=="*"&&(n.country=t[2]),t[3]&&t[3]!=="*"&&(n.city=t[3]),t[4]&&t[4]!=="*"&&(n.workerId=t[4]),n}static getWorkerBindings(e){return[`check.${e.continent}.${e.region}.${e.country}.${e.city}.${e.workerId}`,`check.${e.continent}.${e.region}.${e.country}.${e.city}.*`,`check.${e.continent}.${e.region}.${e.country}.*.*`,`check.${e.continent}.${e.region}.*.*.*`,`check.${e.continent}.*.*.*.*`,"check.*.*.*.*.*"]}},H={CHECKS:"monitoring.checks",CLAIMS:"monitoring.claims",HEARTBEATS:"monitoring.heartbeats",REGISTRATION:"monitoring.registration",RESULTS:"monitoring.results"},N={WORKER_CHECKS:"worker.checks.",WORKER_CLAIMS:"worker.claims.",SCHEDULER_HEARTBEATS:"scheduler.heartbeats",SCHEDULER_REGISTRATION:"scheduler.registration",SCHEDULER_RESULTS:"scheduler.results"},G={europe:{name:"Europe",regions:{north:{name:"Northern Europe",countries:{poland:{name:"Poland",cities:["warsaw","krakow","gdansk","poznan"]},germany:{name:"Germany",cities:["berlin","munich","frankfurt","hamburg"]},uk:{name:"United Kingdom",cities:["london","manchester","birmingham","glasgow"]}}},west:{name:"Western Europe",countries:{france:{name:"France",cities:["paris","lyon","marseille","toulouse"]},netherlands:{name:"Netherlands",cities:["amsterdam","rotterdam","hague","utrecht"]}}},south:{name:"Southern Europe",countries:{spain:{name:"Spain",cities:["madrid","barcelona","valencia","seville"]},italy:{name:"Italy",cities:["rome","milan","naples","turin"]}}}}},northamerica:{name:"North America",regions:{east:{name:"US East",countries:{usa:{name:"United States",cities:["newyork","washington","boston","atlanta"]}}},west:{name:"US West",countries:{usa:{name:"United States",cities:["sanfrancisco","losangeles","seattle","portland"]}}},central:{name:"US Central",countries:{usa:{name:"United States",cities:["chicago","dallas","houston","denver"]}}}}},asia:{name:"Asia",regions:{east:{name:"East Asia",countries:{japan:{name:"Japan",cities:["tokyo","osaka","kyoto","yokohama"]},korea:{name:"South Korea",cities:["seoul","busan","incheon","daegu"]}}},southeast:{name:"Southeast Asia",countries:{singapore:{name:"Singapore",cities:["singapore"]},thailand:{name:"Thailand",cities:["bangkok","chiangmai","phuket"]}}},south:{name:"South Asia",countries:{india:{name:"India",cities:["mumbai","delhi","bangalore","chennai"]}}}}},oceania:{name:"Oceania",regions:{australia:{name:"Australia",countries:{australia:{name:"Australia",cities:["sydney","melbourne","brisbane","perth"]}}},newzealand:{name:"New Zealand",countries:{newzealand:{name:"New Zealand",cities:["auckland","wellington","christchurch"]}}}}}}});var b=exports&&exports.__importDefault||function(r){return r&&r.__esModule?r:{default:r}};Object.defineProperty(exports,"__esModule",{value:!0});exports.GeographicWorker=void 0;var O=b(require("amqplib")),_=b(require("axios")),L=(I(),E(S)),s=(C(),E(y)),i=(0,L.createLogger)("geographic-worker"),m=class{constructor(e){this.config=e,this.connection=null,this.channel=null,this.activeChecks=new Map,this.heartbeatInterval=null,this.HEARTBEAT_INTERVAL=3e4,this.CHECK_TIMEOUT=3e4,this.CLAIM_TIMEOUT=2e3,this.registration={workerId:e.workerId,location:e.location,capabilities:e.capabilities||["http","https"],version:e.version||"1.0.0",registeredAt:Date.now(),lastHeartbeat:Date.now()}}async start(){try{await this.connectToRabbitMQ(),await this.setupExchanges(),await this.setupQueues(),await this.register(),this.startHeartbeat(),await this.listenForChecks(),i.info(`\u2705 Worker ${this.config.workerId} started`,{location:this.config.location})}catch(e){throw i.error("Failed to start worker",{message:e.message,stack:e.stack,code:e.code}),e}}async connectToRabbitMQ(){this.connection=await O.default.connect(this.config.rabbitmqUrl),this.connection.on("error",e=>{i.error("RabbitMQ connection error",e),this.reconnect()}),this.connection.on("close",()=>{i.warn("RabbitMQ connection closed"),this.reconnect()}),this.channel=await this.connection.createChannel(),i.info("\u2705 Connected to RabbitMQ")}async reconnect(){i.info("Attempting to reconnect..."),setTimeout(()=>this.start(),5e3)}async register(){if(!this.channel)throw new Error("Channel not initialized");let e=0,t=10,n=6e4;for(;e<t;){e++,i.info(`\u{1F4E4} Sending registration (attempt ${e}/${t})...`);let a=await this.channel.assertQueue("",{exclusive:!0}),h=`ack.${this.config.workerId}`;if(await this.channel.bindQueue(a.queue,s.EXCHANGES.REGISTRATION,h),i.info(`\u{1F4EE} ACK queue ready: ${a.queue} bound to ${s.EXCHANGES.REGISTRATION} with key: ${h}`),await this.channel.publish(s.EXCHANGES.REGISTRATION,"register",Buffer.from(JSON.stringify(this.registration))),i.info(`\u23F3 Waiting for ACK on ${h} (timeout: ${n/1e3}s)`),await new Promise(c=>{let u=setTimeout(()=>{i.warn(`\u23F1\uFE0F ACK timeout for ${this.config.workerId} after ${n/1e3} seconds (attempt ${e}/${t})`),c(!1)},n);this.channel.consume(a.queue,o=>{if(i.debug("\u{1F514} Message received on ACK queue"),o)try{i.debug("\u{1F4E6} Message details:",{exchange:o.fields.exchange,routingKey:o.fields.routingKey,contentType:o.properties.contentType});let g=JSON.parse(o.content.toString());i.info("\u{1F4E8} Received ACK:",g),clearTimeout(u),this.channel.ack(o),c(!0)}catch(g){i.error("\u274C Failed to parse ACK message:",g),i.error("Raw message:",o.content.toString())}else i.debug("\u26A0\uFE0F Null message received")},{noAck:!1}).then(o=>{i.debug(`\u{1F442} Consumer started with tag: ${o.consumerTag}`)})})){i.info(`\u2705 Worker registered with scheduler after ${e} attempt(s)`);return}await this.channel.deleteQueue(a.queue),e<t&&(i.warn("\u26A0\uFE0F Registration not acknowledged, retrying in 10 seconds..."),await new Promise(c=>setTimeout(c,1e4)))}i.error(`\u274C Failed to register after ${t} attempts. Worker will continue without scheduler confirmation.`),i.info("\u{1F4AA} Worker proceeding in standalone mode - will process any incoming check requests")}async setupExchanges(){if(!this.channel)throw new Error("Channel not initialized");let e=[{name:s.EXCHANGES.CHECKS,type:"topic"},{name:s.EXCHANGES.CLAIMS,type:"direct"},{name:s.EXCHANGES.RESULTS,type:"topic"},{name:s.EXCHANGES.REGISTRATION,type:"topic"},{name:s.EXCHANGES.HEARTBEATS,type:"topic"}];for(let t of e)try{await this.channel.assertExchange(t.name,t.type,{durable:!0}),i.debug(`Created/verified exchange ${t.name} (${t.type})`)}catch(n){if(n.message&&n.message.includes("inequivalent"))i.warn(`Exchange ${t.name} exists with different type, using existing`);else throw i.error(`Failed to create exchange ${t.name}:`,n.message),n}i.info("\u2705 Exchanges configured")}async setupQueues(){if(!this.channel)throw new Error("Channel not initialized");let e=`${s.QUEUE_PREFIXES.WORKER_CHECKS}${this.config.workerId}`;await this.channel.assertQueue(e,{durable:!0});let t=s.RoutingKeyBuilder.getWorkerBindings(this.config.location);for(let a of t)await this.channel.bindQueue(e,s.EXCHANGES.CHECKS,a),i.debug(`Bound to routing key: ${a}`);let n=`${s.QUEUE_PREFIXES.WORKER_CLAIMS}${this.config.workerId}`;await this.channel.assertQueue(n,{durable:!0}),await this.channel.bindQueue(n,s.EXCHANGES.CLAIMS,`response.${this.config.workerId}`),i.info("\u2705 Queues and bindings configured")}async listenForChecks(){if(!this.channel)throw new Error("Channel not initialized");let e=`${s.QUEUE_PREFIXES.WORKER_CHECKS}${this.config.workerId}`;await this.channel.consume(e,async t=>{if(t)try{let n=JSON.parse(t.content.toString());if(i.info(`\u{1F4E5} Received check task ${n.id}`,{serviceId:n.serviceId,target:n.target}),!await this.claimTask(n)){i.info(`\u274C Task ${n.id} claimed by another worker, skipping`),this.channel.ack(t);return}let h=await this.executeCheck(n);await this.sendResult(n,h),this.channel.ack(t)}catch(n){i.error("Failed to process check",n),this.channel.nack(t,!1,!1)}}),i.info("\u{1F442} Listening for check tasks")}async claimTask(e){if(!this.channel)throw new Error("Channel not initialized");let t={taskId:e.id,workerId:this.config.workerId,timestamp:Date.now()};await this.channel.publish(s.EXCHANGES.CLAIMS,"request",Buffer.from(JSON.stringify(t)));let n=`${s.QUEUE_PREFIXES.WORKER_CLAIMS}${this.config.workerId}`;return new Promise(a=>{let h=setTimeout(()=>{i.warn(`Claim timeout for task ${e.id}, proceeding anyway`),a(!0)},this.CLAIM_TIMEOUT),f=this.channel.consume(n,c=>{if(c)try{let u=JSON.parse(c.content.toString());u.taskId===e.id&&(clearTimeout(h),this.channel.ack(c),this.channel.cancel(f.consumerTag),a(u.approved))}catch(u){i.error("Failed to parse claim response",u)}})})}async executeCheck(e){let t=Date.now();try{let n=await(0,_.default)({method:e.config?.method||"GET",url:e.target,timeout:this.CHECK_TIMEOUT,headers:e.config?.headers||{},validateStatus:()=>!0}),a=Date.now()-t;return{status:n.status<400?"up":"down",statusCode:n.status,responseTime:a,timestamp:Date.now(),workerId:this.config.workerId,location:this.config.location}}catch(n){return{status:"down",responseTime:Date.now()-t,timestamp:Date.now(),workerId:this.config.workerId,location:this.config.location,error:n.message||"Check failed"}}}async sendResult(e,t){if(!this.channel)throw new Error("Channel not initialized");let n={taskId:e.id,serviceId:e.serviceId,nestId:e.nestId,...t};await this.channel.publish(s.EXCHANGES.RESULTS,`check.${this.config.workerId}`,Buffer.from(JSON.stringify(n)),{persistent:!0}),i.info(`\u2705 Result sent for task ${e.id}`,{status:t.status,responseTime:t.responseTime})}startHeartbeat(){this.heartbeatInterval=setInterval(async()=>{if(this.channel)try{let e={workerId:this.config.workerId,location:this.config.location,timestamp:Date.now(),lastSeen:Date.now(),activeChecks:this.activeChecks.size,uptime:Date.now()-this.registration.registeredAt,region:this.config.location.region||"unknown",version:this.config.version||"6.4.4",checksCompleted:0,totalPoints:0,currentPeriodPoints:0,earnings:{points:0,estimatedUSD:0,estimatedCrypto:0}};await this.channel.publish(s.EXCHANGES.HEARTBEATS,"worker",Buffer.from(JSON.stringify(e))),i.debug("\u{1F493} Heartbeat sent")}catch(e){i.error("Failed to send heartbeat",e)}},this.HEARTBEAT_INTERVAL)}async stop(){i.info("Stopping worker..."),this.heartbeatInterval&&clearInterval(this.heartbeatInterval),this.channel&&await this.channel.publish(s.EXCHANGES.REGISTRATION,"unregister",Buffer.from(JSON.stringify({workerId:this.config.workerId}))),this.channel&&await this.channel.close(),this.connection&&await this.connection.close(),i.info("Worker stopped")}};exports.GeographicWorker=m;
